import { useMemo, useCallback, useEffect } from "react";

import {
  Sidebar,
  ConversationList,
  Avatar,
  ChatContainer,
  ConversationHeader,
  MessageGroup,
  Message,
  MessageList,
  MessageInput,
  TypingIndicator,
  MainContainer,
} from "@chatscope/chat-ui-kit-react";

import {
  useChat,
  ChatMessage,
  Conversation,
  ConversationId
  ConversationRole,
  MessageContent,
  MessageContentType,
  MessageDirection,
  MessageStatus,
  Participant,
  TextContent,
  TypingUsersList,
  User as ChatUser,
  User,
} from "@chatscope/use-chat";
import { Database } from "@/types/supabase";
import { createClient } from "@/utils/supabase/client";

export type ServiceProvider =
  Database["public"]["Tables"]["service_providers"]["Row"];
export type Customer = Database["public"]["Tables"]["customers"]["Row"];

const getServiceProvider = async () => {};

const createChatUser = (user: ServiceProvider | Customer): ChatUser =>
  new ChatUser({
    id: user.user_id,
    firstName: user.preferred_name,
    username: user.preferred_name,
    avatar: user.profile_picture ?? "",
  });

function createConversation(id: ConversationId, name: string): Conversation {
  return new Conversation({
    id,
    participants: [
      new Participant({
        id: name,
        role: new ConversationRole([]),
      }),
    ],
    unreadCounter: 0,
    typingUsers: new TypingUsersList({ items: [] }),
    draft: "",
  });
}

export const Chat = ({ userId }: { userId: string }) => {
  const supabase = createClient();

  // Get all chat related values and methods from useChat hook
  const {
    currentMessages,
    conversations,
    activeConversation,
    setActiveConversation,
    sendMessage,
    getUser,
    currentMessage,
    setCurrentMessage,
    sendTyping,
    setCurrentUser,
  } = useChat();

  useEffect(() => {
    const getThreads = async () => {
      const { data, error } = await supabase
        .from("threads")
        .select("*, service_providers(*), customers(*)")
        .or(`customer_id.eq.${userId},service_provider_id.eq.${userId}`);
      // get service provider from supabase
      // then convert to chat user

      setCurrentUser(user);
    };
  }, [user, setCurrentUser]);

  // Get current user data
  const [currentUserAvatar, currentUserName] = useMemo(() => {
    if (activeConversation) {
      const participant =
        activeConversation.participants.length > 0
          ? activeConversation.participants[0]
          : undefined;

      if (participant) {
        const user = getUser(participant.id);
        if (user) {
          return [
            <Avatar key={participant.id} src={user.avatar} />,
            user.username,
          ];
        }
      }
    }

    return [undefined, undefined];
  }, [activeConversation, getUser]);

  const handleChange = (value: string) => {
    // Send typing indicator to the active conversation
    // You can call this method on each onChange event
    // because sendTyping method can throttle sending this event
    // So typing event will not be send to often to the server
    setCurrentMessage(value);
    if (activeConversation) {
      sendTyping({
        conversationId: activeConversation?.id,
        isTyping: true,
        userId: user.id,
        content: value, // Note! Most often you don't want to send what the user types, as this can violate his privacy!
        throttle: true,
      });
    }
  };

  const handleSend = (text: string) => {
    const message = new ChatMessage({
      id: "", // Id will be generated by storage generator, so here you can pass an empty string
      content: text as unknown as MessageContent<TextContent>,
      contentType: MessageContentType.TextHtml,
      senderId: user.id,
      direction: MessageDirection.Outgoing,
      status: MessageStatus.Sent,
    });

    if (activeConversation) {
      sendMessage({
        message,
        conversationId: activeConversation.id,
        senderId: user.id,
      });
    }
  };

  const getTypingIndicator = useCallback(() => {
    if (activeConversation) {
      const typingUsers = activeConversation.typingUsers;

      if (typingUsers.length > 0) {
        const typingUserId = typingUsers.items[0].userId;

        // Check if typing user participates in the conversation
        if (activeConversation.participantExists(typingUserId)) {
          const typingUser = getUser(typingUserId);

          if (typingUser) {
            return (
              <TypingIndicator content={`${typingUser.username} is typing`} />
            );
          }
        }
      }
    }

    return undefined;
  }, [activeConversation, getUser]);

  return (
    <MainContainer>
      <Sidebar position="left" scrollable>
        <ConversationHeader style={{ backgroundColor: "#fff" }}>
          <Avatar src={user.avatar} />
          <ConversationHeader.Content>
            {user.username}
          </ConversationHeader.Content>
        </ConversationHeader>
        <ConversationList>
          {conversations.map((c) => {
            // Helper for getting the data of the first participant
            const [avatar, name] = (() => {
              const participant =
                c.participants.length > 0 ? c.participants[0] : undefined;

              if (participant) {
                const user = getUser(participant.id);
                if (user) {
                  return [
                    <Avatar key={participant.id} src={user.avatar} />,
                    user.username,
                  ];
                }
              }

              return [undefined, undefined];
            })();

            return (
              <Conversation
                key={c.id}
                name={name}
                info={
                  c.draft
                    ? `Draft: ${c.draft
                        .replace(/<br>/g, "\n")
                        .replace(/&nbsp;/g, " ")}`
                    : ``
                }
                active={activeConversation?.id === c.id}
                unreadCnt={c.unreadCounter}
                onClick={() => setActiveConversation(c.id)}
              >
                {avatar}
              </Conversation>
            );
          })}
        </ConversationList>
      </Sidebar>
    </MainContainer>
  );
};
